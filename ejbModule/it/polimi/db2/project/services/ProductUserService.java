package it.polimi.db2.project.services;

import java.util.List;
import javax.ejb.Stateless;
import javax.persistence.EntityManager;
import javax.persistence.PersistenceContext;
import it.polimi.db2.project.entities.Product;
import it.polimi.db2.project.entities.QuestionnaireResponse;
import it.polimi.db2.project.entities.User;
import it.polimi.db2.project.exceptions.ApplicationErrorException;
import it.polimi.db2.project.exceptions.NoProductOfTheDayException;

/**
 * 
 * This class will provide a service for the actions on Product
 * done by users.
 *
 */
@Stateless
public class ProductUserService {
	/**
	 * JPA Entity Manager
	 * it is extended in order to let it live until the user calls the "remove" method.
	 */
	@PersistenceContext(unitName = "DB2Project_EJB")
	private EntityManager em;
	
	/**
	 * This is needed to get the product of the day
	 * 
	 * @return the product of the day
	 * @throws NoProductOfTheDayException if there is no available product of the day to return
	 */
	public Product getProductOfTheDay() throws NoProductOfTheDayException {
		// Initializing the list of products
		List<Product> prodList = null;
		
		/**
		 * Here we are retrieving the product of the day
		 */
		try {
			prodList = em.createNamedQuery("Product.getProductOfTheDayToday", Product.class)
					.getResultList();
		}
		catch(IllegalArgumentException e) {
			//e.printStackTrace();
			throw new NoProductOfTheDayException("Unable to retrieve the product of the day.");
		}
		
		// if the product is not 1, then it means we do not have a product of the day to display
		if(prodList == null || prodList.isEmpty() || prodList.size() != 1)
			throw new NoProductOfTheDayException("The number of product of that day is not 1");

		// if here we are sure to have the product of the day "not null" and that is unique
		//	thanks to the exceptions
		
		Product prodDay = prodList.get(0);
		
		return prodDay;
	}
	
	/**
	 * It is used to know if the user has already submitted the product of the day
	 * for this day or not.
	 * @param user the user we want to know
	 * @return true if already sumbitted, false otherwise
	 * @throws ApplicationErrorException if there are problems with the request
	 */
	public boolean answeredToQuestionnaireOfTheDay(User user) throws ApplicationErrorException {
		/**
		 * getting the product of the day
		 */
		List<Product> retrieved_products;
		try {
			retrieved_products = em.createNamedQuery("Product.getProductOfTheDayToday", Product.class)
					.getResultList();
		}
		catch (IllegalArgumentException e) {
			throw new ApplicationErrorException("Cannot fullfil the request");
		}
		
		// if no product of the day, cannot continue!
		if (retrieved_products == null || retrieved_products.isEmpty() || retrieved_products.size() != 1) 
				return false;
		
		
		// this is the product of the day
		Product product = retrieved_products.get(0);
		
		/**
		 * checking if already answered
		 */
		List<QuestionnaireResponse> responses;
		try {
			responses = em.createQuery(
					"SELECT r FROM Product p JOIN p.questionnaireResponses r WHERE p.id = ?1 AND r.user.id = ?2", 
					QuestionnaireResponse.class)
					.setParameter(1, product.getId())
					.setParameter(2, user.getId())
					.getResultList();
		}
		catch (IllegalArgumentException e) {
			throw new ApplicationErrorException("Cannot fullfil the request");
		}
		
		// if we find responses
		if(responses != null && !responses.isEmpty() && responses.size() != 0)
			return true;
		
		// no responses found
		return false;
	}
	
	/**
	 * Method used to retrieve the list of reviews of a product, in order to be shown together in the front end with the 
	 * product of the day. N.B.: there are two cases in which the returned list is null:
	 *    1) no other user has reviewed the product yet;
	 *    2) everyone (except me) who reviewed the product, canceled the questionnaire (= did not submitted it), and therefore that answer must
	 *       not be shown to the common user.
	 * @param userId the id of the user who is performing the request
	 * @return list of Questionnaire Responses
	 * @throws NoProductOfTheDayException if there is an error generated by retrieving the product of the day
	 * @throws ApplicationErrorException when unable to retrieve reviews
	 */
	public List<QuestionnaireResponse> getReviewsOfTheProductOfTheDay(Integer userId) throws NoProductOfTheDayException, ApplicationErrorException {
		
		/**
		 * Initializing the list as null
		 */
		List<QuestionnaireResponse> temporaryList = null;
		
		/**
		 * Setting a temporary product in order to perform a named query
		 */
		Product prodDay = null;
		try {
			prodDay = getProductOfTheDay();
		}catch(NoProductOfTheDayException e) {
			//e.printStackTrace();
			return temporaryList; // it will be null
		}
		
		/**
		 * We have a single product for sure, otherwise we would have thrown the exceptions, and we want to retrieve all the related 
		 * answers by users. The answer by a user is composed from the statistical answers and the marketing answer, but there is no 
		 * need to retrieve them: the fetch type of the statistical answer is eager by default since is an object, and the statistical 
		 * answer of the collection of marketing answers is set by default as EAGER from the code, hence when we retrieve the 
		 * questionnaire responses, we are retrieving all the pending items. Now we need to perform a query. What will be returned?
		 * the list of SUBMITTED questionnaire response (without the "canceled" ones, because a normal user has no permission to 
		 * see it). The list will be null if:
		 *    1) no other user reviewed the product (nor submitted nor canceled)
		 *    2) no other user submitted the questionnaire (just canceled ones)
		 */
		try {
			//this query retrieves a list of questionnaire responses correlated to the product passed as parameter.
			//in the named query is checked that "submitted=1" => not canceled.
			temporaryList = em.createNamedQuery("QuestionnaireResponse.SubmittedQuestionnaireOfProductExceptSpecifiedUser", 
					QuestionnaireResponse.class)
					.setParameter("productOfTheDay", prodDay.getId())
					.setParameter("submitted", true)
					.setParameter("userId", userId)
					.getResultList();
		}catch(IllegalArgumentException e) {
			//e.printStackTrace();
			throw new ApplicationErrorException("Unable to retrieve submitted quastionnaires relative to product with id = "+
					prodDay.getId()+".");
		}
		
		/**
		 * Returning the list
		 */
		return temporaryList;
	}
}